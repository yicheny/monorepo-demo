# 序
我想写一篇关于`monorepo`的笔记，和大家分享，但是从哪里开始说呢？

我很纠结，一方面`monorepo`的内容很多，我掌握了一部分`monorepo`的知识，有一套自己喜欢的做法，然而同时我也知道这未必是最好的做法。

不过，我想我未必需要分享最好的做法，只要它是有效的做法，它就是有意义的，如果真的有人因此产生兴趣，更深入的使用和研究`monorepo`，那样岂不是更好？

另一方面是，`monorepo`并不是在任何时候都应该使用的，作为工具，在合适的时候使用才能最大程度的发挥其作用，在我们对`monorepo`有一个基本了解之后，我们来讨论下`monorepo`在什么时候应用可以发挥它的力量。

我会以下面的思路进行分享：
1. 关于`monorepo`的基本概念，什么是`monorepo`
2. `monorepo`的优势，使用它可以带来哪些好处
3. 怎么应用`monorepo`，在实践中使用`monorepo`
4. 讨论`monorepo`的应用场景，什么场合使用`monorepo`比较好
5. 相关资料

# 基本概念
什么是 `monorepo` ？

`monorepo`可以理解为一种基于仓库的代码管理策略，它提出将多个 **独立的代码工程** 放到一个仓库里的管理模式。

这里最关键的就是“独立”这个词，每个代码工程在逻辑上是可以独立运行以及维护管理的，这一点非常重要。

为什么这一点非常重要？如果代码工程不是独立的，那它就不是`monorepo`模式，而是`single-repo Monolith`，这种模式正是最原始的项目仓库管理模式之一。

这里我们说一下3种项目仓库管理模式：
1. `single-repo Monolith`
2. `multi-repo`
3. `monorepo`

我们可以看一下它们各自的架构特征：

![3种模式](https://uploads.toptal.io/blog/image/129133/toptal-blog-image-1550062710292-1db9f4f6ffc00e30acb3a43b3504c4a9.png)

通过这张图我们来说一下三种策略的核心不同：
1. `Monorepo`：只有一个仓库，并且把项目拆分多个独立的代码工程进行管理，而代码工程之间可以通过相应的工具简单的进行代码共享。
2. `Single-repo Monolith`：同样也只有一个仓库，而它并不会独立的分割每个代码工程，而是让他们成为一体来进行开发管理，模块的拆分取决于代码工程的设计。 
3. `Multi-repo`：则是通过建立多个仓库，每个仓库包含拆分好的代码工程，而仓库间的调用共享则是通过`NPM`或者其他代码引用的方式进行。

虽然这样可以简单的区别三种策略，而实际情况下，这三种策略其实是可以相互转换，相互包含的。 

一个`Monorepo`里可以包含多个以`Single-repo Monolith`形式组织的代码。`Multi-repo`中的每个`repo`都可以是一个`Monorepo`等等。

所以，灵活的使用每种策略和组合策略才能更加高效的管理更为复杂多变的情形。

纯粹的描述定义可能比较抽象，不是很容易理解，下面我要结合项目给出一些更具体的场景，然后我们和对比下这三种模式的区别。

我们先看`single-repo monolith`，这个我们应该是最熟悉的：

> 注：项目组织形式可以有很多种，根据实际场景和架构师对模块的设计理念会有所不同，这里用的是我们实际项目所使用的项目架构，因为这样大家会比较熟悉，理解起来也比较快。

```
- project
    - package.json
    - src
        - views
            - swap
            - option
            - base
            - submission
        - utils
        - components
```

这是一个简单的项目结构，可以看到我们在`views`下放置了不同的业务模块，在`multi-repo`和`monorepo`中，它们是独立的项目，可以单独的编译、启动和部署。在`single-repo monolith`模式下，它们虽然业务有所不同，虽然我们概念上有“模块”不同的区分，但是依旧同属于同一个代码工程下，代码被杂糅混合在一起，整个项目会共同进行构建和部署。

关于业务模块不独立，代码杂糅，是我们需要关注的第1个部分，非常重要，这里先暂且记下。

我们再看下公共代码复用的问题。

这里的`utils`、`components`代表的是公共的方法和组件，这两个目录下的文件和代码允许在不同的业务模块中使用。

然后在`single-repo monolith`下，业务模块是怎么引用公共方法和组件的呢？

通常来说有两种方式：
1. 通过`../../utils`这种相对路径引用
2. 通过配置设置绝对地址`alias`引用，比如说`@utils`这样

到这里，我们对`single-repo monolith`的模式有一个基本的理解。

这里我们稍作停顿，考虑下这种模式的缺点是什么？

……

关于这个模式的缺点，大家应该都有自己的看法和观点，我说一下我的想法，去年（2022）年的时候，对`otcd`项目有做过微服务的拆分，当时将`otcd`项目拆分成了多个小项目。

这么做固然有业务上面的因素，不过我想问一下各位，将`otcd`单个项目拆分成多个项目，对于我们来说有什么影响，从我们开发的角度来说，带来了哪些方便的地方，同时有带来了哪些痛点？

从我个人经历来说，其实我在前两年就想着拆分微服务的，当时我和冯老师提出想法之后，我当时为什么提出拆分微服务，具体可以看一下我的这个笔记 [项目中遇到的问题及其解决方案](http://note.youdao.com/noteshare?id=92b6c26e6bb5bc9343ad275fd2d7e4f4&sub=3EF7EC5D008A49A2AF055A91A0AFCC9C)，当时项目中遇到了很多问题，这里记录了一部分项目的问题以及我提出的解决方案。

我还是简单要说一下当时的场景（其实原本我都忘了，不过看了笔记又会想起过去的很多事情，另一方面从笔记的记录里我发现当时记录的问题恰好正式`single-repo monolith`的一个绝妙佐证）

仅以`single-repo monolith`相关的问题来说主要有两个：性能【运行、编译、部署】、代码管理

首先说一下性能的问题。

`otcd`的团队和代码规模在公司的前端项目中是很大的，极有可能是最大的一个前端项目，可以肯定在当时是公司最大的web前端项目（现在的话可能不一定了），当时随着项目越变越大，项目在启动和运行的时间逐渐变长，从原来的三四分钟增加到七八分种，甚至十分钟以上，尤为让我难受的是，联调或者修复一些缺陷时需要频繁重启服务，这极大的影响了开发者的心态和开发效率。

另一方面，编译时间也显著增加了，此时也经常出现编译部署失败的问题，如果某一模块出错，比如说引用异常或者`eslint`检查不通过，会导致整个项目编译失败，需要重新来过，成本是很高的。（而且我们知道，在我们的构建系统中，部署中或者部署出错，这个服务暂时就没法用了，那么这种情况下，受到影响的不只是前端，包括测试、产品、后端，或者说整个产品线的人都会收到影响，影响范围是很大的）

然后是代码管理的问题，主要有两个问题。

第1个问题是：公共内容几乎都被放在根目录下。这里有人可能会有疑问，难道公共内容不应该放在公共目录下吗？注意，“根目录”并不等同于公共目录。

公共内容是有层级之分的，举例来说，一些基础组件比如说`Tag`、`Anchor`、`ErrorTip`这一类是会在所有模块页面中都可以使用的，与之类似的还有一些公共方法和类。

而另一些模块，比如说期权报送，它也是一个公共组件，但是它只在报送模块的几个页面中使用。首先，类似期权报送这一类组件，它有没有必要抽象成公共组件？它在多个页面中被使用多次，而且规模和功能较大，维护修改不易，从这些方面考虑，当然应该提炼出来。

然而，将这类公共组件放到根目录下合理吗？我们知道`otcd`存在`option`、`swap`、`submission`、`base`、`system`这几个业务模块，当时就是将每个业务模块的公共组件都放到根目录下，以此导致了两个主要问题：
1. 根目录下的公共内容极速增长，因为原本应该只放所有模块公用的内容，但是现在单个业务模块下的公共内容，也被放到根目录下，导致根目录下的文件规模极速扩张，但是对于其他业务模块的人来说这部分内容难以被利用到，导致了公共文件的使用难度，我在做代码检查的时候，发现有很多几乎完全相同的场景，却没有使用公共组件，这是因为公共内容太多，大多数人很难掌握其中的内容，所以放弃了对公共内容的使用，从而自己进行开发。然而，这里有一点让人感到疑惑？明明根目录下的公共内容这么多，难道没有人使用吗？这是一个很好的问题，它涉及到另一个重要的方面，之后我会进行说明，大家可以先想一下，可能存在的问题是什么？这个问题很关键
2. 

如果项目规模相对不大，可能不会有这种感受。

# 资料